//
//  Extensions.swift
//  gogo-ios
//
//  Created by Hongli Yu on 14/04/2017.
//  Copyright Â© 2017 Hongli Yu. All rights reserved.
//

import Foundation
import UIKit

extension UINavigationBar {
    
    /// Returns a UIImageView which is the line of the navigation bar
    fileprivate func hairlineImageViewInNavigationBar(_ view: UIView) -> UIImageView? {
        if let imageView = view as? UIImageView, imageView.bounds.height <= 1 {
            return imageView
        }
        for subview: UIView in view.subviews {
            if let imageView = hairlineImageViewInNavigationBar(subview) {
                return imageView
            }
        }
        return nil
    }
    
    /// change the alpha of the buttom line
    func adjustBottomHairlineAlpha(_ alpha: CGFloat) {
        let imageView = hairlineImageViewInNavigationBar(self)
        imageView?.alpha = alpha
    }
    
    /// Hide the buttom line of the navigation bar
    func hideBottomHairline() {
        hairlineImageViewInNavigationBar(self)?.isHidden = true
    }
    
    /// show the buttom line of the navigation bar
    func showBottomHairline() {
        hairlineImageViewInNavigationBar(self)?.isHidden = false
    }
    
    /// hide navigation bar
    func becomeTransparent(_ transparent: Bool, tintColor: UIColor, titleColor: UIColor) {
        if transparent {
            hideBottomHairline()
            setBackgroundImage(UIImage(), for: .default)
            shadowImage = UIImage()
            UIApplication.shared.statusBarStyle = UIStatusBarStyle.lightContent
            titleTextAttributes = [NSForegroundColorAttributeName: titleColor]
            self.tintColor = tintColor
        } else {
            showBottomHairline()
            setBackgroundImage(nil, for: .default)
            shadowImage = nil
            UIApplication.shared.statusBarStyle = UIStatusBarStyle.default
            titleTextAttributes = [NSForegroundColorAttributeName: titleColor]
            self.tintColor = tintColor
        }
    }
    
}

// Hack the back button generated by storyboard
@objc protocol BackButtonHandlerProtocol {
    // Override this method in UIViewController derived class to handle 'Back' button click
    @objc optional func navigationShouldPopOnBackButton() -> Bool
}

extension UINavigationController: UINavigationBarDelegate {
    
    public func navigationBar(_ navigationBar: UINavigationBar,
                              shouldPop item: UINavigationItem) -> Bool {
        guard let itemsCount = self.navigationBar.items?.count else {
            return false
        }
        if self.viewControllers.count < itemsCount {
            return true
        }
        var shouldPop: Bool = true
        
        // MARK: more vc is coming
        if self.topViewController != nil && self.topViewController is ArtWorksViewController {
            let topVC: ArtWorksViewController = self.topViewController! as! ArtWorksViewController
            shouldPop = topVC.navigationShouldPopOnBackButton()
        }
        
        if shouldPop {
            DispatchQueue.main.async(execute: {
                self.popViewController(animated: true)
            })
        } else {
            for subview in navigationBar.subviews {
                if 0 < subview.alpha && subview.alpha < 1 {
                    UIView.animate(withDuration: 0.25, animations: {
                        subview.alpha = 1
                    })
                }
            }
        }
        return false
    }
    
}

extension Array where Element: AnyObject {
    
    mutating func remove(object: Element) {
        if let index = index(where: { $0 === object }) {
            remove(at: index)
        }
    }
    
}

extension String {
    
    func replace(target: String, withString: String) -> String {
        return self.replacingOccurrences(of: target, with: withString, options: NSString.CompareOptions.literal, range: nil)
    }
    
}

extension UIFont {
    
    class func icomoon(ofSize: CGFloat) -> UIFont? {
        return UIFont(name: "icomoon", size: ofSize)
    }
    
    class func iconfont(ofSize: CGFloat) -> UIFont? {
        return UIFont(name: "iconfont", size: ofSize)
    }
    
}

extension UIImage {
    
    convenience init?(text: Iconfont, fontSize: CGFloat,
                      imageSize: CGSize = CGSize.zero, imageColor: UIColor = UIColor.black) {
        guard let iconfont = UIFont.iconfont(ofSize: fontSize) else {
            self.init()
            return nil
        }
        var imageRect = CGRect(origin: CGPoint.zero, size: imageSize)
        if __CGSizeEqualToSize(imageSize, CGSize.zero) {
            imageRect = CGRect(origin: CGPoint.zero,
                               size: text.rawValue.size(attributes: [NSFontAttributeName: iconfont]))
        }
        UIGraphicsBeginImageContextWithOptions(imageRect.size, false, UIScreen.main.scale)
        defer {
            UIGraphicsEndImageContext()
        }
        let paragraphStyle = NSMutableParagraphStyle()
        paragraphStyle.alignment = NSTextAlignment.center
        text.rawValue.draw(in: imageRect, withAttributes: [NSFontAttributeName : iconfont,
                                                           NSParagraphStyleAttributeName: paragraphStyle,
                                                           NSForegroundColorAttributeName: imageColor])
        guard let cgImage = UIGraphicsGetImageFromCurrentImageContext()?.cgImage else {
            self.init()
            return nil
        }
        self.init(cgImage: cgImage)
    }
    
    static func compress(image: UIImage,
                         maxFileSize: Int, // kb
        compression: CGFloat = 1.0,
        maxCompression: CGFloat = 0.4) -> Data? {
        
        if let data = UIImageJPEGRepresentation(image, compression) {
            let bcf = ByteCountFormatter()
            bcf.allowedUnits = [.useKB] // optional: restricts the units to KB only
            bcf.countStyle = .file
            let string = bcf.string(fromByteCount: Int64(data.count))
            #if DEBUG
                print("Data size is: \(string)")
            #endif
            if data.count > (maxFileSize * 1024) && (compression > maxCompression) {
                let newCompression = compression - 0.1
                let compressedData = self.compress(image: image, maxFileSize: maxFileSize, compression: newCompression, maxCompression: maxCompression)
                return compressedData
            }
            return data
        }
        return nil
    }

}

